import{Vector3 as e,Angle as t,Color3 as s,Color4 as i,Texture as r,VRExperienceHelper as n,Engine as a,Scene as o,MeshBuilder as c,HemisphericLight as h,SpotLight as d,DirectionalLight as m,PointLight as l,StandardMaterial as u,ParticleSystem as p,AssetsManager as g}from"./babylon.module.js";import{System as f}from"https://ecsy.io/build/ecsy.module.js";class Transform{constructor(){this.position={x:0,y:0,z:0},this.rotation={x:0,y:0,z:0},this.scale={x:1,y:1,z:1}}}class Camera{constructor(){this.options={}}}var y,b,S,x,C,M,j,E,_;!function(e){e.Box="Box",e.Plane="Plane",e.Sphere="Sphere",e.Ground="Ground"}(y||(y={}));class Mesh{constructor(){this.type=y.Box,this.options={}}}!function(e){e.Point="Point",e.Directional="Directional",e.Spot="Spot",e.Hemispheric="Hemispheric"}(b||(b={}));class Light{constructor(){this.type=b.Hemispheric,this.direction={x:0,y:0,z:0}}}class Material{constructor(){this.diffuse="#ffffff"}}!function(e){e.Point="Point",e.Box="Box",e.Sphere="Sphere",e.DirectedSphere="DirectedSphere",e.Hemisphere="Hemisphere",e.Cylinder="Cylinder",e.DirectedCylinder="DirectedCylinder",e.Cone="Cone"}(S||(S={}));class Particle{constructor(){this.type=S.Point,this.capacity=100,this.emitter={x:0,y:0,z:0},this.direction1={x:0,y:0,z:0},this.direction2={x:0,y:10,z:10}}}!function(e){e.babylon="Babylon"}(x||(x={}));class Asset{constructor(){this.type=x.babylon}}function v(e){return t.FromDegrees(e).radians()}function q(e){return e.world}function P(e){e.object&&e.object.dispose()}function T(e,t){return q(e).getSystems().find(e=>void 0!==e.activeScene).getScene(t)}function w(t){return new e(t.x,t.y,t.z)}function k(e){return s.FromHexString(e)}function L(e,t,s){Object.keys(t).forEach(i=>{let n=t[i],a=new r(n.url,T(s,e.sceneName));Object.keys(n).filter(e=>"url"===e).forEach(e=>{a[e]=n[e]}),e.object[`${i}Texture`]&&P(e.object[`${i}Texture`]),e.object[`${i}Texture`]=a})}function D(e,t){if(t.object){let s=t.object;s.position&&(s.position=w(e.position)),s.rotation&&s.rotation.set(v(e.rotation.x),v(e.rotation.y),v(e.rotation.z)),s.scaling&&(s.scaling=w(e.scale))}}class GameSystem extends f{constructor(){super(...arguments),this.scenes=new Map,this._lastTime=0,this._isRendering=!1}get activeScene(){return this._activeScene}init(){this._render=this._render.bind(this)}execute(){this.queries.camera.added.forEach(e=>{let t=e.getComponent(Camera),s=this.getScene(t.sceneName);t.object=new n(s,t.options),s===this._activeScene&&(this._isRendering=!0)}),this.queries.camera.removed.forEach(e=>{let t=e.getComponent(Camera);P(t),this.getScene(t.sceneName)===this._activeScene&&(this._isRendering=!1)})}start(e,t,s,i){return this.engine=new a(e,t,s,i),this._lastTime=performance.now(),this.engine.runRenderLoop(this._render),this}getScene(e){return e?this.scenes.get(e):this._activeScene}addScene(e,t){let s=new o(this.engine,t);return this.scenes.set(e,s),1===this.engine.scenes.length&&(this._activeScene=s),this}_render(){let e=performance.now();q(this).execute(e-this._lastTime,e),this._isRendering&&q(this).enabled&&this._activeScene.render(),this._lastTime=e}}GameSystem.queries={camera:{components:[Camera],listen:{added:!0,removed:!0}}};class TransformSystem extends f{init(){window.addEventListener("load",()=>{this.queries.object.results.forEach(e=>{this._updateTransform(e.getComponent(Transform),e.getComponents())})})}execute(){this.queries.object.changed.forEach(e=>{this._updateTransform(e.getComponent(Transform),e.getComponents())})}_updateTransform(e,t){Object.keys(t).filter(e=>void 0!==t[e].object).forEach(s=>D(e,t[s]))}}TransformSystem.queries={object:{components:[Transform],listen:{changed:[Transform]}}};class MeshSystem extends f{execute(){this.queries.mesh.added.forEach(e=>{let t=e.getComponent(Mesh);t.object=c[`Create${t.type}`].call(null,t.type,t.options,T(this,t.sceneName))}),this.queries.mesh.removed.forEach(e=>{P(e.getComponent(Mesh))})}}MeshSystem.queries={mesh:{components:[Mesh],listen:{added:!0,removed:!0}}},function(e){e.specular="specular"}(C||(C={})),function(e){e.direction="direction"}(M||(M={}));class LightSystem extends f{execute(){this.queries.light.added.forEach(t=>{let s=t.getComponent(Light),i=w(s.direction),r=T(this,s.sceneName);switch(s.type){case b.Point:s.object=new l(s.type,e.Zero(),r);break;case b.Directional:s.object=new m(s.type,i,r);break;case b.Spot:s.object=new d(s.type,e.Zero(),i,v(s.angle),s.exponent,r);break;case b.Hemispheric:s.object=new h(s.type,i,r)}this._updateLight(s)}),this.queries.light.changed.forEach(e=>{this._updateLight(e.getComponent(Light))}),this.queries.light.removed.forEach(e=>{P(e.getComponent(Light))})}_updateLight(e){let t=e.object;Object.keys(e).forEach(s=>{C[s]?t[s]=k(e[s]):M[s]?t[s]=w(e[s]):t[s]=e[s]})}}LightSystem.queries={light:{components:[Light],listen:{added:!0,removed:!0,changed:!0}}},function(e){e.diffuse="diffuse",e.specular="specular",e.emissive="emissive",e.ambient="ambient"}(j||(j={}));class MaterialSystem extends f{execute(){this.queries.meshMaterial.added.forEach(e=>{let t=e.getComponent(Material);t.object=new u(t.diffuse,T(this,t.sceneName)),this._updateMaterial(t),e.getComponent(Mesh).object.material=t.object}),this.queries.meshMaterial.changed.forEach(e=>{this._updateMaterial(e.getComponent(Material))}),this.queries.meshMaterial.removed.forEach(e=>{P(e.getComponent(Material)),e.getComponent(Mesh).object.material=null})}_updateMaterial(e){let t=e.object;Object.keys(e).forEach(s=>{j[s]?t[`${s}Color`]=k(e[s]):"texture"===s?e.texture&&L(e,e.texture,this):t[s]=e[s]})}}MaterialSystem.queries={meshMaterial:{components:[Mesh,Material],listen:{added:!0,removed:!0,changed:[Material]}}},function(e){e.textureMask="textureMask"}(E||(E={})),function(e){e.emitter="emitter",e.direction1="direction1",e.direction2="direction2"}(_||(_={}));class ParticleSystem extends f{execute(){this.queries.particle.added.forEach(e=>{let t=e.getComponent(Particle);t.object=new p(t.type,t.capacity,T(this,t.sceneName));let s=t.object;switch(t.type){case S.Point:s.createPointEmitter(w(t.direction1),w(t.direction2));break;case S.Box:s.createBoxEmitter(w(t.direction1),w(t.direction2),w(t.minEmitBox),w(t.maxEmitBox));break;case S.Sphere:s.createSphereEmitter(t.radius,t.radiusRange);break;case S.DirectedSphere:s.createDirectedSphereEmitter(t.radius,w(t.direction1),w(t.direction2));break;case S.Hemisphere:s.createHemisphericEmitter(t.radius,t.radiusRange);break;case S.Cylinder:s.createCylinderEmitter(t.radius,t.height,t.radiusRange,Math.random());break;case S.DirectedCylinder:s.createDirectedCylinderEmitter(t.radius,t.height,t.radiusRange,w(t.direction1),w(t.direction2));break;case S.Cone:s.createConeEmitter(t.radius,t.angle)}this._updateParticle(t),s.start()}),this.queries.particle.changed.forEach(e=>{this._updateParticle(e.getComponent(Particle))}),this.queries.particle.removed.forEach(e=>{let t=e.getComponent(Particle);t.object.stop(),P(t)})}_updateParticle(e){let t=e.object;Object.keys(e).forEach(s=>{_[s]?t[s]=w(e[s]):E[s]?t[s]=function(e){return i.FromHexString(e)}(e[s]):"texture"===s?e.texture&&L(e,e.texture,this):t[s]=e[s]})}}ParticleSystem.queries={particle:{components:[Particle],listen:{added:!0,changed:!0,removed:!0}}};class AssetSystem extends f{execute(){this.queries.asset.added.forEach(e=>{let t=e.getComponent(Asset);switch(this.assetManager||(this.assetManager=new g(T(this,t.sceneName))),this.assetManager.useDefaultLoadingScreen=!1,t.type){case x.babylon:{let s=t.url.lastIndexOf("/")+1;this.assetManager.addMeshTask(t.type,"",t.url.substring(0,s),t.url.substring(s,t.url.length)).onSuccess=s=>{t.object=s.loadedMeshes[0],D(e.getComponent(Transform),t)};break}}this.assetManager.load()}),this.queries.asset.removed.forEach(e=>{P(e.getComponent(Asset))})}}AssetSystem.queries={asset:{components:[Transform,Asset],listen:{added:!0,removed:!0}}};export{Asset,AssetSystem,x as AssetTypes,Camera,GameSystem,Light,LightSystem,b as LightTypes,Material,MaterialSystem,Mesh,MeshSystem,y as MeshTypes,Particle,ParticleSystem,S as ParticleTypes,Transform,TransformSystem};
