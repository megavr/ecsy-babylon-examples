import{Observable as e,Engine as t,Scene as s,AssetsManager as r,Angle as i,Vector3 as n,Color3 as a,Color4 as o,FreeCamera as c,MeshBuilder as h,HemisphericLight as d,SpotLight as l,DirectionalLight as m,PointLight as u,StandardMaterial as p,ParticleSystem as g}from"./babylon.module.js";import{System as f}from"./ecsy.module.js";function y(e){return e.world}class GameSystem extends f{constructor(){super(...arguments),this._scenes=new Map,this._assetManagers=new Map,this.onSceneSwitched=new e}get renderingCanvas(){return this._engine.getRenderingCanvas()}get activeSceneName(){return this._activeSceneName}init(){this._render=this._render.bind(this)}start(e,s,r,i){return this._engine=new t(e,s,r,i),this._engine.runRenderLoop(this._render),this}addScene(e,t){let i=new s(this._engine,t);this._scenes.set(e,i);let n=new r(i);return n.useDefaultLoadingScreen=!1,this._assetManagers.set(e,n),1===this._engine.scenes.length&&(this._activeSceneName=e),this}removeScene(e){return e!==this.activeSceneName&&this.getScene(e).dispose(),this}switchScene(e){return this.getScene(e)&&(this._activeSceneName=e,this.onSceneSwitched.notifyObservers(this.getScene(e))),this}getScene(e){return e?this._scenes.get(e):this._scenes.get(this._activeSceneName)}getAssetManager(e){return e?this._assetManagers.get(e):this._assetManagers.get(this._activeSceneName)}_render(){y(this).execute(this._engine.getDeltaTime(),performance.now()),y(this).enabled&&this.getScene().render()}}function S(e,t,s){return e&&t&&s?{x:e,y:t,z:s}:{x:0,y:0,z:0}}class Transform{constructor(){this.position=S(),this.rotation=S(),this.scale=S(1,1,1)}}class Camera{constructor(){this.pointerLock=!1}}var b,C,x,M,_;!function(e){e.Box="Box",e.Plane="Plane",e.Sphere="Sphere",e.Ground="Ground"}(b||(b={}));class Mesh{constructor(){this.type=b.Box,this.options={}}}!function(e){e.Point="Point",e.Directional="Directional",e.Spot="Spot",e.Hemispheric="Hemispheric"}(C||(C={}));class Light{constructor(){this.type=C.Hemispheric,this.direction=S()}}function E(e){return y(e).getSystem(GameSystem)}function v(e,t){return E(e).getScene(t)}function w(e,t){return E(e).getAssetManager(t)}function q(e){return E(e).activeSceneName}function j(e){return i.FromDegrees(e).radians()}function P(e){return i.FromRadians(e).degrees()}function k(e){return new n(e.x,e.y,e.z)}function L(e){return new n(j(e.x),j(e.y),j(e.z))}function N(e){return{x:e.x,y:e.y,z:e.z}}function B(e){return{x:e.x,y:e.y,z:e.z}}function D(e){return a.FromHexString(e)}function T(e){return o.FromHexString(e)}function A(e,t){e.object[t]=e[t]}function H(e,t){e.object[t]=k(e[t])}function I(e){let t=e.getComponents();for(let s in t){let r=t[s];r.object&&e.hasComponent(Transform)&&K(e.getMutableComponent(Transform),r)}}function K(e,t){let s=t.object;s.position&&(s.position=k(e.position)),s.rotation&&(s.rotation=L(e.rotation)),s.scaling&&(s.scaling=k(e.scale))}function z(e){e.object&&e.object.dispose()}function O(e,t,s){for(let r in t){let i=t[r];s.addTextureTask(r,i.url).onSuccess=t=>{let s=t.texture;for(let e in i)"url"!==e&&(s[e]=i[e]);let n=`${r}Texture`,a=e.object;a[n]&&z(a[n]),a[n]=s}}s.load(),s.reset()}class Material{constructor(){var e;this.color=e?{diffuse:e}:{diffuse:"#ffffff"}}}!function(e){e.Point="Point",e.Box="Box",e.Sphere="Sphere",e.DirectedSphere="DirectedSphere",e.Hemisphere="Hemisphere",e.Cylinder="Cylinder",e.DirectedCylinder="DirectedCylinder",e.Cone="Cone"}(x||(x={}));class Particle{constructor(){this.type=x.Point,this.capacity=100,this.emitter=S(),this.direction1=S(),this.direction2=S(10,10,10),this.minEmitBox=S(),this.maxEmitBox=S()}}!function(e){e.Babylon="Babylon"}(M||(M={}));class Asset{constructor(){this.type=M.Babylon}}!function(e){e.Keyboard="Keyboard"}(_||(_={}));class Input{constructor(){this.type=_.Keyboard}}class TransformSystem extends f{execute(){this.queries.transforms.changed.forEach(e=>{I(e)})}}TransformSystem.queries={transforms:{components:[Transform],listen:{changed:[Transform]}}};class CameraSystem extends f{constructor(){super(...arguments),this._cameraOfScenes=new Map}init(){E(this).onSceneSwitched.add(e=>this._updateControl(e.uid))}execute(){this.queries.camera.added.forEach(e=>{let t=e.getComponent(Camera),s=v(this,t.sceneName);this._cameraOfScenes.set(s.uid,t),t.object=new c("",n.Zero(),s),I(e),this._updateControl(s.uid)}),this.queries.camera.removed.forEach(e=>{z(e.getComponent(Camera))})}_updateControl(e){let t=v(this,q(this));if(t.uid===e){let s=this._cameraOfScenes.get(e),r=E(this).renderingCanvas;s.object.attachControl(r,!0),s.pointerLock&&(t.onPointerDown=()=>{document.pointerLockElement||r.requestPointerLock()})}}}CameraSystem.queries={camera:{components:[Camera],listen:{added:!0,removed:!0}}};class MeshSystem extends f{execute(){this.queries.mesh.added.forEach(e=>{let t=e.getComponent(Mesh);t.object=h[`Create${t.type}`].call(this,t.type,t.options,v(this,t.sceneName)),I(e)}),this.queries.mesh.changed.forEach(e=>{let t=e.getMutableComponent(Mesh);for(let e in t)A(t,e)}),this.queries.mesh.removed.forEach(e=>{z(e.getComponent(Mesh))})}}MeshSystem.queries={mesh:{components:[Mesh],listen:{added:!0,removed:!0,changed:[Mesh]}}};class LightSystem extends f{execute(){this.queries.light.added.forEach(e=>{let t=e.getComponent(Light),s=k(t.direction),r=v(this,t.sceneName);switch(t.type){case C.Point:t.object=new u(t.type,n.Zero(),r);break;case C.Directional:t.object=new m(t.type,s,r);break;case C.Spot:t.object=new l(t.type,n.Zero(),s,j(t.angle),t.exponent,r);break;default:t.object=new d(C.Hemispheric,s,r)}this._updateLight(t),I(e)}),this.queries.light.changed.forEach(e=>{this._updateLight(e.getComponent(Light))}),this.queries.light.removed.forEach(e=>{z(e.getComponent(Light))})}_updateLight(e){for(let t in e)switch(t){case"direction":H(e,t);break;case"color":this._updateColor(e,e.color);break;default:A(e,t)}}_updateColor(e,t){for(let s in t)e.object[s]=D(t[s])}}LightSystem.queries={light:{components:[Light],listen:{added:!0,removed:!0,changed:[Light]}}};class MaterialSystem extends f{execute(){this.queries.meshMaterial.added.forEach(e=>{let t=e.getComponent(Material);t.object=new p(t.color.diffuse,v(this,t.sceneName)),this._updateMaterial(t),e.getComponent(Mesh).object.material=t.object}),this.queries.meshMaterial.changed.forEach(e=>{this._updateMaterial(e.getComponent(Material))}),this.queries.meshMaterial.removed.forEach(e=>{z(e.getComponent(Material)),e.getComponent(Mesh).object.material=null})}_updateMaterial(e){for(let t in e)switch(t){case"color":this._updateColor(e,e.color);break;case"texture":O(e,e.texture,w(this,e.sceneName));break;default:A(e,t)}}_updateColor(e,t){for(let s in t)e.object[`${s}Color`]=D(t[s])}}MaterialSystem.queries={meshMaterial:{components:[Mesh,Material],listen:{added:!0,removed:!0,changed:[Material]}}};class ParticleSystem extends f{execute(){this.queries.particle.added.forEach(e=>{let t=e.getComponent(Particle);t.object=new g(t.type,t.capacity,v(this,t.sceneName));let s=t.object;switch(t.type){case x.Point:s.createPointEmitter(k(t.direction1),k(t.direction2));break;case x.Box:s.createBoxEmitter(k(t.direction1),k(t.direction2),k(t.minEmitBox),k(t.maxEmitBox));break;case x.Sphere:s.createSphereEmitter(t.radius,t.radiusRange);break;case x.DirectedSphere:s.createDirectedSphereEmitter(t.radius,k(t.direction1),k(t.direction2));break;case x.Hemisphere:s.createHemisphericEmitter(t.radius,t.radiusRange);break;case x.Cylinder:s.createCylinderEmitter(t.radius,t.height,t.radiusRange,Math.random());break;case x.DirectedCylinder:s.createDirectedCylinderEmitter(t.radius,t.height,t.radiusRange,k(t.direction1),k(t.direction2));break;case x.Cone:s.createConeEmitter(t.radius,t.angle)}this._updateParticle(t),I(e),s.start()}),this.queries.particle.changed.forEach(e=>{this._updateParticle(e.getComponent(Particle))}),this.queries.particle.removed.forEach(e=>{let t=e.getComponent(Particle);t.object.stop(),z(t)})}_updateParticle(e){for(let t in e)switch(t){case"emitter":case"direction1":case"direction2":case"minEmitBox":case"maxEmitBox":H(e,t);break;case"texture":O(e,e.texture,w(this,e.sceneName));break;case"color":this._updateColor(e,e.color);break;default:A(e,t)}}_updateColor(e,t){for(let s in t)e.object[s]=T(t[s])}}ParticleSystem.queries={particle:{components:[Particle],listen:{added:!0,removed:!0,changed:[Particle]}}};class AssetSystem extends f{execute(){this.queries.asset.added.forEach(e=>{let t=e.getComponent(Asset),s=w(this,t.sceneName);switch(t.type){default:{let r=t.url.lastIndexOf("/")+1;s.addMeshTask(M.Babylon,"",t.url.substring(0,r),t.url.substring(r,t.url.length)).onSuccess=s=>{t.object=s.loadedMeshes[0],I(e)};break}}s.load(),s.reset()}),this.queries.asset.removed.forEach(e=>{z(e.getComponent(Asset))})}}AssetSystem.queries={asset:{components:[Asset],listen:{added:!0,removed:!0}}};class InputSystem extends f{execute(){this.queries.input.added.forEach(e=>{let t=e.getComponent(Input);switch(t.type){case _.Keyboard:t.onKey&&v(this,t.sceneName).onKeyboardObservable.add(e=>t.onKey.call(t,e.event.key,1===e.type,2===e.type))}}),this.queries.input.removed.forEach(e=>{let t=e.getComponent(Input);switch(t.type){case _.Keyboard:v(this,t.sceneName).onKeyboardObservable.clear()}})}}InputSystem.queries={input:{components:[Input],listen:{added:!0,removed:!0}}};export{Asset,AssetSystem,M as AssetTypes,Camera,CameraSystem,GameSystem,Input,InputSystem,_ as InputTypes,Light,LightSystem,C as LightTypes,Material,MaterialSystem,Mesh,MeshSystem,b as MeshTypes,Particle,ParticleSystem,x as ParticleTypes,Transform,TransformSystem,j as degreeToRadians,q as getActiveSceneName,w as getAssetManager,v as getScene,D as hexToColor3,T as hexToColor4,P as radiansToDegree,N as vector3ToXyz,B as vector3ToXyzDegree,k as xyzToVector3,L as xyzToVector3Radians};
