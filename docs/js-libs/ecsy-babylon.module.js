import{Angle as e,Vector3 as t,Color3 as s,Color4 as i,Observable as n,Scene as r,AssetsManager as o,Engine as a,FreeCamera as c,MeshBuilder as h,HemisphericLight as d,SpotLight as u,DirectionalLight as l,PointLight as m,StandardMaterial as p,ParticleSystem as g}from"./babylon.module.js";import{System as f}from"./ecsy.module.js";class Scene{constructor(){this.options={}}}function y(t){return e.FromDegrees(t).radians()}function b(e){return new t(e.x,e.y,e.z)}function S(e){return new t(y(e.x),y(e.y),y(e.z))}function _(e,t,s){return e&&t&&s?{x:e,y:t,z:s}:{x:0,y:0,z:0}}class Transform{constructor(){this.position=_(),this.rotation=_(),this.scale=_(1,1,1)}}class Camera{constructor(){this.pointerLock=!1}}var C,x,M,v,E;!function(e){e.Box="Box",e.Plane="Plane",e.Sphere="Sphere",e.Ground="Ground"}(C||(C={}));class Mesh{constructor(){this.type=C.Box,this.options={}}}!function(e){e.Point="Point",e.Directional="Directional",e.Spot="Spot",e.Hemispheric="Hemispheric"}(x||(x={}));class Light{constructor(){this.type=x.Hemispheric,this.direction=_()}}function j(e,t){e.object[t]=e[t]}function k(e,t){e.object[t]=b(e[t])}function q(e){let t=e.getComponents();for(let s in t){let i=t[s];i.object&&e.hasComponent(Transform)&&w(e.getMutableComponent(Transform),i)}}function w(e,t){let s=t.object;s.position&&(s.position=b(e.position)),s.rotation&&(s.rotation=S(e.rotation)),s.scaling&&(s.scaling=b(e.scale))}function P(e){e.object&&e.object.dispose()}function L(e,t,s){for(let i in t){let n=t[i];s.addTextureTask(i,n.url).onSuccess=t=>{let s=t.texture;for(let e in n)"url"!==e&&(s[e]=n[e]);let r=`${i}Texture`,o=e.object;o[r]&&P(o[r]),o[r]=s}}s.load(),s.reset()}function K(e){return s.FromHexString(e)}function B(e){return i.FromHexString(e)}class Material{constructor(){var e;this.color=e?{diffuse:e}:{diffuse:"#ffffff"}}}!function(e){e.Point="Point",e.Box="Box",e.Sphere="Sphere",e.DirectedSphere="DirectedSphere",e.Hemisphere="Hemisphere",e.Cylinder="Cylinder",e.DirectedCylinder="DirectedCylinder",e.Cone="Cone"}(M||(M={}));class Particle{constructor(){this.type=M.Point,this.capacity=100,this.emitter=_(),this.direction1=_(),this.direction2=_(10,10,10),this.minEmitBox=_(),this.maxEmitBox=_()}}!function(e){e.Babylon="Babylon"}(v||(v={}));class Asset{constructor(){this.type=v.Babylon}}!function(e){e.Keyboard="Keyboard"}(E||(E={}));class Input{constructor(){this.type=E.Keyboard}}function D(e){return e.world}class GameSystem extends f{constructor(){super(...arguments),this._assetManagers=new Map,this.onSceneSwitched=new n}get renderingCanvas(){return this._engine.getRenderingCanvas()}get scenes(){return this._engine.scenes}get activeScene(){return this._activeScene}init(){this._render=this._render.bind(this)}execute(){this.queries.scene.added.forEach(e=>{let t=e.getComponent(Scene);t.object=new r(this._engine,t.options),1===this._engine.scenes.length&&(this._activeScene=t.object),this._updateScene(e);let s=new o(t.object);s.useDefaultLoadingScreen=!1,this._assetManagers.set(t.object.uid,s)}),this.queries.scene.changed.forEach(e=>{this._updateScene(e)}),this.queries.scene.removed.forEach(e=>{P(e.getComponent(Scene))})}_updateScene(e){let t=e.getComponent(Scene);for(let s in t)switch(s){case"texture":L(t,t.texture,this.getAssetManager(e));break;case"color":this._updateColor(t,t.color);break;default:j(t,s)}}_updateColor(e,t){for(let s in t)switch(s){case"clear":e.object[`${s}Color`]=B(t[s]);break;default:e.object[`${s}Color`]=K(t[s])}}start(e,t,s,i){return this._engine=new a(e,t,s,i),this._engine.runRenderLoop(this._render),this}switchScene(e){return this._activeScene=e.getComponent(Scene).object,this.onSceneSwitched.notifyObservers(this._activeScene),this}getAssetManager(e){return e?this._assetManagers.get(e.getComponent(Scene).object.uid):this._assetManagers.get(this._activeScene.uid)}_render(){D(this).execute(this._engine.getDeltaTime(),performance.now()),D(this).enabled&&this._activeScene.render()}}GameSystem.queries={scene:{components:[Scene],listen:{added:!0,removed:!0,changed:[Scene]}}};class TransformSystem extends f{execute(){this.queries.transforms.changed.forEach(e=>{q(e)})}}function T(e){return D(e).getSystem(GameSystem)}function O(e){return T(e).renderingCanvas}function A(e){return T(e).scenes}function H(e,t){return t?t.getComponent(Scene).object:T(e).activeScene}function I(e,t){return T(e).getAssetManager(t)}TransformSystem.queries={transforms:{components:[Transform],listen:{changed:[Transform]}}};class CameraSystem extends f{constructor(){super(...arguments),this._cameras=new Map}init(){T(this).onSceneSwitched.add(e=>this._updateControl(e)),this._pointerLock=this._pointerLock.bind(this)}execute(){this.queries.camera.added.forEach(e=>{let s=e.getComponent(Camera),i=H(this,s.scene);s.object=new c("",t.Zero(),i),q(e),this._cameras.set(i.uid,s),this._updateControl(i)}),this.queries.camera.removed.forEach(e=>{let t=e.getComponent(Camera),s=H(this,t.scene);this._removeControl(s),this._cameras.has(s.uid)&&this._cameras.delete(s.uid),P(t)})}_updateControl(e){if(e.uid===H(this).uid){A(this).forEach(e=>this._removeControl(e));let t=this._cameras.get(e.uid);t.object.attachControl(O(this)),t.pointerLock?e.onPointerObservable.add(this._pointerLock):document.exitPointerLock()}}_removeControl(e){this._cameras.forEach((t,s)=>s===e.uid&&t.object.detachControl(O(this))),e.onPointerObservable.removeCallback(this._pointerLock)}_pointerLock(e){"pointerdown"===e.event.type&&(document.pointerLockElement||O(this).requestPointerLock())}}CameraSystem.queries={camera:{components:[Camera],listen:{added:!0,removed:!0}}};class MeshSystem extends f{execute(){this.queries.mesh.added.forEach(e=>{let t=e.getComponent(Mesh);t.object=h[`Create${t.type}`].call(this,t.type,t.options,H(this,t.scene)),q(e)}),this.queries.mesh.changed.forEach(e=>{let t=e.getMutableComponent(Mesh);for(let e in t)j(t,e)}),this.queries.mesh.removed.forEach(e=>{P(e.getComponent(Mesh))})}}MeshSystem.queries={mesh:{components:[Mesh],listen:{added:!0,removed:!0,changed:[Mesh]}}};class LightSystem extends f{execute(){this.queries.light.added.forEach(e=>{let s=e.getComponent(Light),i=b(s.direction),n=H(this,s.scene);switch(s.type){case x.Point:s.object=new m(s.type,t.Zero(),n);break;case x.Directional:s.object=new l(s.type,i,n);break;case x.Spot:s.object=new u(s.type,t.Zero(),i,y(s.angle),s.exponent,n);break;default:s.object=new d(x.Hemispheric,i,n)}this._updateLight(s),q(e)}),this.queries.light.changed.forEach(e=>{this._updateLight(e.getComponent(Light))}),this.queries.light.removed.forEach(e=>{P(e.getComponent(Light))})}_updateLight(e){for(let t in e)switch(t){case"direction":k(e,t);break;case"color":this._updateColor(e,e.color);break;default:j(e,t)}}_updateColor(e,t){for(let s in t)e.object[s]=K(t[s])}}LightSystem.queries={light:{components:[Light],listen:{added:!0,removed:!0,changed:[Light]}}};class MaterialSystem extends f{execute(){this.queries.meshMaterial.added.forEach(e=>{let t=e.getComponent(Material);t.object=new p(t.color.diffuse,H(this,t.scene)),this._updateMaterial(t),e.getComponent(Mesh).object.material=t.object}),this.queries.meshMaterial.changed.forEach(e=>{this._updateMaterial(e.getComponent(Material))}),this.queries.meshMaterial.removed.forEach(e=>{P(e.getComponent(Material)),e.getComponent(Mesh).object.material=null})}_updateMaterial(e){for(let t in e)switch(t){case"color":this._updateColor(e,e.color);break;case"texture":L(e,e.texture,I(this,e.scene));break;default:j(e,t)}}_updateColor(e,t){for(let s in t)e.object[`${s}Color`]=K(t[s])}}MaterialSystem.queries={meshMaterial:{components:[Mesh,Material],listen:{added:!0,removed:!0,changed:[Material]}}};class ParticleSystem extends f{execute(){this.queries.particle.added.forEach(e=>{let t=e.getComponent(Particle);t.object=new g(t.type,t.capacity,H(this,t.scene));let s=t.object;switch(t.type){case M.Point:s.createPointEmitter(b(t.direction1),b(t.direction2));break;case M.Box:s.createBoxEmitter(b(t.direction1),b(t.direction2),b(t.minEmitBox),b(t.maxEmitBox));break;case M.Sphere:s.createSphereEmitter(t.radius,t.radiusRange);break;case M.DirectedSphere:s.createDirectedSphereEmitter(t.radius,b(t.direction1),b(t.direction2));break;case M.Hemisphere:s.createHemisphericEmitter(t.radius,t.radiusRange);break;case M.Cylinder:s.createCylinderEmitter(t.radius,t.height,t.radiusRange,Math.random());break;case M.DirectedCylinder:s.createDirectedCylinderEmitter(t.radius,t.height,t.radiusRange,b(t.direction1),b(t.direction2));break;case M.Cone:s.createConeEmitter(t.radius,t.angle)}this._updateParticle(t),q(e),s.start()}),this.queries.particle.changed.forEach(e=>{this._updateParticle(e.getComponent(Particle))}),this.queries.particle.removed.forEach(e=>{let t=e.getComponent(Particle);t.object.stop(),P(t)})}_updateParticle(e){for(let t in e)switch(t){case"emitter":case"direction1":case"direction2":case"minEmitBox":case"maxEmitBox":k(e,t);break;case"texture":L(e,e.texture,I(this,e.scene));break;case"color":this._updateColor(e,e.color);break;default:j(e,t)}}_updateColor(e,t){for(let s in t)e.object[s]=B(t[s])}}ParticleSystem.queries={particle:{components:[Particle],listen:{added:!0,removed:!0,changed:[Particle]}}};class AssetSystem extends f{execute(){this.queries.asset.added.forEach(e=>{let t=e.getComponent(Asset),s=I(this,t.scene);switch(t.type){default:{let i=t.url.lastIndexOf("/")+1;s.addMeshTask(v.Babylon,"",t.url.substring(0,i),t.url.substring(i,t.url.length)).onSuccess=s=>{t.object=s.loadedMeshes[0],q(e)};break}}s.load(),s.reset()}),this.queries.asset.removed.forEach(e=>{P(e.getComponent(Asset))})}}AssetSystem.queries={asset:{components:[Asset],listen:{added:!0,removed:!0}}};class InputSystem extends f{constructor(){super(...arguments),this._inputs=new Map}init(){T(this).onSceneSwitched.add(e=>this._updateOnKey(e)),this._onKey=this._onKey.bind(this)}execute(){this.queries.input.added.forEach(e=>{let t=e.getComponent(Input),s=H(this,t.scene);t.type,this._inputs.has(s.uid)||(this._inputs.set(s.uid,t),this._updateOnKey(s))}),this.queries.input.removed.forEach(e=>{let t=e.getComponent(Input),s=H(this,t.scene);t.type,this._inputs.has(s.uid)&&(this._inputs.delete(s.uid),this._removeOnKey(s))})}_updateOnKey(e){e.uid===H(this).uid&&(A(this).forEach(e=>this._removeOnKey(e)),this._input=this._inputs.get(e.uid),this._input.onKey&&e.onKeyboardObservable.add(this._onKey))}_removeOnKey(e){e.onKeyboardObservable.removeCallback(this._onKey)}_onKey(e){this._input.onKey.call(this._input,e.event.key,1===e.type,2===e.type)}}InputSystem.queries={input:{components:[Input],listen:{added:!0,removed:!0}}};export{Asset,AssetSystem,v as AssetTypes,Camera,CameraSystem,GameSystem,Input,InputSystem,E as InputTypes,Light,LightSystem,x as LightTypes,Material,MaterialSystem,Mesh,MeshSystem,C as MeshTypes,Particle,ParticleSystem,M as ParticleTypes,Scene,Transform,TransformSystem,y as degreeToRadians,I as getAssetManager,H as getScene,K as hexToColor3,B as hexToColor4,b as xyzToVector3,S as xyzToVector3Radians};
